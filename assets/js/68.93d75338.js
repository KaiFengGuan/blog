(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{629:function(t,e,s){"use strict";s.r(e);var a=s(10),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("结合自己阅读过的源码，总结一下Vue相关面试问题该如何回答！\n")]),t._v(" "),s("h2",{attrs:{id:"一、vue实例挂载过程发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、vue实例挂载过程发生了什么"}},[t._v("#")]),t._v(" 一、Vue实例挂载过程发生了什么？")]),t._v(" "),s("p",[t._v("挂载过程指的是"),s("code",[t._v("app.mount()")]),t._v("过程，主要完成两件事情："),s("strong",[t._v("初始化")]),t._v("和"),s("strong",[t._v("建立更新机制")]),t._v("。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("初始化")]),t._v("过程：\n"),s("ul",[s("li",[t._v("创建组件实例、初始化组件状态和实例关系属性、初始化自定义事件等，并调用"),s("code",[t._v("beforeCreate")]),t._v("钩子函数")]),t._v(" "),s("li",[t._v("初始化prop前初始化"),s("code",[t._v("inject")])]),t._v(" "),s("li",[t._v("处理 props、methods、data、computed、watch（"),s("strong",[t._v("数据响应式的重点")]),t._v("）")]),t._v(" "),s("li",[t._v("初始化prop后初始化"),s("code",[t._v("provide")]),t._v("，并调用"),s("code",[t._v("created")]),t._v("钩子函数")]),t._v(" "),s("li",[t._v("挂载到"),s("strong",[t._v("DOM")]),t._v("元素")])])]),t._v(" "),s("li",[s("strong",[t._v("建立更新机制")]),t._v("过程：\n"),s("ul",[s("li",[t._v("立即执行一次"),s("strong",[t._v("组件更新函数")]),s("code",[t._v("vm._update(vm._render(), hydrating)")]),t._v("；")]),t._v(" "),s("li",[t._v("通过"),s("code",[t._v("vm._render()")]),t._v("调用"),s("code",[t._v("_createElement")]),t._v("函数，将模板编译得到的render函数生成vnode；")]),t._v(" "),s("li",[s("code",[t._v("vm._update")]),t._v("会首次执行组件渲染函数并执行patch，将vnode转换为DOM；")]),t._v(" "),s("li",[t._v("同时首次执行渲染函数会创建它内部响应式数据之间和组件更新函数之间的依赖关系（依赖收集），这使得以后数据变化时会执行对应的更新函数。")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("可能继续追问：")]),t._v(" "),s("ol",[s("li",[t._v("响应式数据怎么创立？")]),t._v(" "),s("li",[t._v("依赖关系如何建立？")])])]),t._v(" "),s("h2",{attrs:{id:"二、对vue响应式的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、对vue响应式的理解"}},[t._v("#")]),t._v(" 二、对Vue响应式的理解？")]),t._v(" "),s("p",[t._v("源码在线阅读："),s("a",{attrs:{href:"https://kaifengguan.github.io/blog/docs/vue/vue2sourcecode_03_reactive.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("响应式原理"),s("OutboundLink")],1),t._v("、"),s("a",{attrs:{href:"https://github1s.com/vuejs/vue/blob/HEAD/src/core/observer/index.js#L37",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue2源码 - Observer"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("回答思路：什么是响应式？=> 为什么vue需要响应式？ => 好处是什么？ => 如何实现？优缺点？ => Vue3响应式新变化？")]),t._v(" "),s("ul",[s("li",[t._v("什么是响应式？\n"),s("ul",[s("li",[t._v("响应式就是"),s("strong",[t._v("使数据变化可以被检测并对这种变化做出响应的机制")]),t._v("。")])])]),t._v(" "),s("li",[t._v("为什么需要？\n"),s("ul",[s("li",[t._v("MVVM框架中要解决的一个核心问题是连接数据层和视图层，通过"),s("strong",[t._v("数据驱动")]),t._v("应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。")])])]),t._v(" "),s("li",[t._v("好处？\n"),s("ul",[s("li",[t._v("在Vue框架中，通过数据响应式加上虚拟DOM和patch算法，开发人员只需要操作数据，关心业务，完全不用接触繁琐的DOM操作，从而大大提升开发效率，降低开发难度。")])])]),t._v(" "),s("li",[s("strong",[t._v("如何实现响应式")]),t._v("？优缺点？\n"),s("ul",[s("li",[t._v("根据数据类型来做不同处理：\n"),s("ul",[s("li",[t._v("对于"),s("strong",[t._v("对象")]),t._v("，循环遍历对象的所有属性，"),s("strong",[t._v("采用"),s("code",[t._v("Object.defineProperty()")]),t._v("定义数据属性的getter和setter进行拦截")]),t._v("，当数据被访问或者发生变化的时候，做出感知并响应；如果属性值依旧为对象，则递归；")]),t._v(" "),s("li",[t._v("对于"),s("strong",[t._v("数组")]),t._v("，通过对 7 种数组方法（ push，pop，shift，unshift，splice，sort，reverse）进行重写（AOP 切片思想），增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作；")]),t._v(" "),s("li",[s("strong",[t._v("依赖收集与更新")]),t._v("过程均在响应式这里实现，在访问数据的时候，每个属性维护一个dep，存储相关的watcher，在设置数据的时候，由dep去通知相关的watcher去更新；数组也是如此，另外，删除数据的时候，也由dep通知watcher更新。")])])]),t._v(" "),s("li",[t._v("这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。")])])]),t._v(" "),s("li",[t._v("Vue3响应式新变化：\n"),s("ul",[s("li",[t._v("利用ES6的Proxy代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；")]),t._v(" "),s("li",[t._v("另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，第三方的扩展开发起来更加灵活了。")])])])]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202205161557343.png"}}),t._v(" "),s("blockquote",[s("p",[t._v("扩展：")]),t._v(" "),s("ul",[s("li",[t._v("双向绑定的使用与原理")])])]),t._v(" "),s("h2",{attrs:{id:"三、vue的双向绑定原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、vue的双向绑定原理"}},[t._v("#")]),t._v(" 三、Vue的双向绑定原理")]),t._v(" "),s("p",[t._v("回答思路：定义 => 好处 => 在哪里使用？ => 使用方式、细节、Vue3变化 => 实现原理")]),t._v(" "),s("ul",[s("li",[t._v("什么是双向绑定？\n"),s("ul",[s("li",[t._v("是"),s("code",[t._v("v-model")]),t._v("指令，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。")])])]),t._v(" "),s("li",[t._v("好处："),s("code",[t._v("v-model")]),t._v("是"),s("strong",[t._v("语法糖")]),t._v("，默认情况下相当于"),s("code",[t._v(":value")]),t._v("和"),s("code",[t._v("@input")]),t._v("。使用"),s("code",[t._v("v-model")]),t._v("可以减少大量繁琐的事件处理代码，提高开发效率。")]),t._v(" "),s("li",[t._v("通常在"),s("strong",[t._v("表单项")]),t._v("上使用"),s("code",[t._v("v-model")]),t._v("，还可以在"),s("strong",[t._v("自定义组件")]),t._v("上使用，表示某个值的输入和输出控制。")]),t._v(" "),s("li",[t._v("如何使用：在内部为不同的输入元素使用不同的 property 并抛出不同的事件\n"),s("ul",[s("li",[t._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),t._v(" "),s("li",[t._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),t._v(" "),s("li",[t._v("select 字段将 value 作为 prop 并将 change 作为事件；")]),t._v(" "),s("li",[t._v("可以结合"),s("code",[t._v(".lazy")]),t._v("、"),s("code",[t._v(".number")]),t._v("、"),s("code",[t._v(".trim")]),t._v("等修饰符对v-mode的行为做进一步限定")]),t._v(" "),s("li",[t._v("Vue3中将v-model和"),s("code",[t._v(".sync")]),t._v("整合，可以进行多个v-model绑定，v-model默认传的prop名称由value改成了modelValue；支持添加自定义修饰符；")])])]),t._v(" "),s("li",[s("code",[t._v("v-model")]),t._v("原理：是一个指令，实际上是Vue的编译器完成的\n"),s("ul",[s("li",[t._v("包含"),s("code",[t._v("v-model")]),t._v("的模板，转换为渲染函数之后，实际上还是是value属性的绑定以及input事件监听，事件回调函数中会做相应变量更新操作；")]),t._v(" "),s("li",[t._v("编译器根据表单元素的不同会展开不同的DOM属性和事件对（如上所述）")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("扩展问题")]),s("ul",[s("li",[s("code",[t._v("v-model")]),t._v("和"),s("code",[t._v(".sync")]),t._v("修饰符有什么区别\n"),s("ul",[s("li",[s("code",[t._v(".sync")]),t._v("修饰符也是一个语法糖，给父子组件提供双向绑定（父子通信），实现多个数据的双向绑定")]),t._v(" "),s("li",[t._v("格式不同: "),s("code",[t._v('v-model="num"')]),t._v("、"),s("code",[t._v(':num.sync="num"；')])]),t._v(" "),s("li",[t._v("原理不同："),s("code",[t._v("v-model")]),t._v("是"),s("code",[t._v("@input")]),t._v(" + "),s("code",[t._v("value")]),t._v("；"),s("code",[t._v(".sync")]),t._v("是"),s("code",[t._v("@update:num")]),t._v("；")]),t._v(" "),s("li",[t._v("使用不同："),s("code",[t._v("v-model")]),t._v("只能用一次，"),s("code",[t._v(".sync")]),t._v("可以有多个。")])])]),t._v(" "),s("li",[t._v("自定义组件使用"),s("code",[t._v("v-model")]),t._v("如果想要改变事件名或者属性名应该怎么做\n"),s("ul",[s("li",[t._v("定义组件时，"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用model选项"),s("OutboundLink")],1),t._v("。")])])])])]),s("h2",{attrs:{id:"四、组件之间通信的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、组件之间通信的方式有哪些"}},[t._v("#")]),t._v(" 四、组件之间通信的方式有哪些？")]),t._v(" "),s("p",[t._v("Vue2中可以使用的组件通信方式：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("props")]),t._v("、"),s("code",[t._v("$emit")]),t._v("：父子之间通信")]),t._v(" "),s("li",[s("code",[t._v("$parent")]),t._v("、"),s("code",[t._v("$children")]),t._v("：获取当前组件的父子实例")]),t._v(" "),s("li",[s("code",[t._v("$attrs")]),t._v(" 、"),s("code",[t._v("$listener")])]),t._v(" "),s("li",[s("code",[t._v("$refs")]),t._v("：获取注册过"),s("code",[t._v("ref")]),t._v("属性的所有 DOM 元素和组件实例")]),t._v(" "),s("li",[s("code",[t._v("$root")]),t._v("：获取当前组件树的根 Vue 实例")]),t._v(" "),s("li",[s("code",[t._v("provide")]),t._v("、"),s("code",[t._v("inject")]),t._v("：父组件provide，子组件inject")]),t._v(" "),s("li",[t._v("eventBus：通过"),s("code",[t._v("$on")]),t._v("、"),s("code",[t._v("$off")]),t._v("、"),s("code",[t._v("$once")]),t._v("实现"),s("a",{attrs:{href:"https://blog.csdn.net/qq_26834399/article/details/106387585",target:"_blank",rel:"noopener noreferrer"}},[t._v("全局定义全局使用"),s("OutboundLink")],1),t._v("（类似发布订阅模式）。")]),t._v(" "),s("li",[t._v("Vuex：全局状态管理")])]),t._v(" "),s("p",[t._v("Vue3移除的部分：")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://v3-migration.vuejs.org/breaking-changes/children.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("$children")]),s("OutboundLink")],1),t._v("；"),s("a",{attrs:{href:"https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("$listener")]),s("OutboundLink")],1),t._v("；"),s("a",{attrs:{href:"https://v3-migration.vuejs.org/breaking-changes/events-api.html#_2-x-syntax",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("$on")]),t._v("、"),s("code",[t._v("$off")]),t._v("、"),s("code",[t._v("$once")]),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("回答这个问题，可以根据"),s("strong",[t._v("组件之间的关系")]),t._v("来切入：")]),t._v(" "),s("ul",[s("li",[t._v("父子组件："),s("code",[t._v("props")]),t._v("、"),s("code",[t._v("$emit")]),t._v("、"),s("code",[t._v("$parent")]),t._v("、"),s("code",[t._v("$refs")]),t._v("、"),s("code",[t._v("$attrs")]),t._v("；")]),t._v(" "),s("li",[t._v("兄弟组件："),s("code",[t._v("$parent")]),t._v("、"),s("code",[t._v("$root")]),t._v("、eventBus、Vuex；")]),t._v(" "),s("li",[t._v("跨层级关系：eventBus、Vuex、"),s("code",[t._v("provide")]),t._v("+"),s("code",[t._v("inject")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"五、vue生命周期-每个阶段发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、vue生命周期-每个阶段发生了什么"}},[t._v("#")]),t._v(" 五、Vue生命周期？每个阶段发生了什么？")]),t._v(" "),s("p",[t._v("回答思路：生命周期概念 => 列举阶段，整体流程 => 实践 => Vue3变化")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测，模板编译，挂载实例到DOM上，以及数据变化时更新DOM。"),s("strong",[t._v("这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("生命周期总共可以分为8个阶段："),s("strong",[t._v("创建前后, 载入前后, 更新前后, 销毁前后")]),t._v("，以及一些特殊场景的生命周期：")]),t._v(" "),s("p",[t._v("常规生命周期钩子：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Vue2")]),t._v(" "),s("th",[t._v("Vue3")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("beforeCreate")]),t._v(" "),s("td",[t._v("beforeCreate")]),t._v(" "),s("td",[t._v("组件实例被创建之初")])]),t._v(" "),s("tr",[s("td",[t._v("created")]),t._v(" "),s("td",[t._v("created")]),t._v(" "),s("td",[t._v("组件实例已经完全创建")])]),t._v(" "),s("tr",[s("td",[t._v("beforeMount")]),t._v(" "),s("td",[t._v("beforeMount")]),t._v(" "),s("td",[t._v("组件挂载之前")])]),t._v(" "),s("tr",[s("td",[t._v("mounted")]),t._v(" "),s("td",[t._v("mounted")]),t._v(" "),s("td",[t._v("组件挂载到实例上去之后")])]),t._v(" "),s("tr",[s("td",[t._v("beforeUpdate")]),t._v(" "),s("td",[t._v("beforeUpdate")]),t._v(" "),s("td",[t._v("组件数据发生变化，更新之前")])]),t._v(" "),s("tr",[s("td",[t._v("updated")]),t._v(" "),s("td",[t._v("updated")]),t._v(" "),s("td",[t._v("数据数据更新之后")])]),t._v(" "),s("tr",[s("td",[t._v("beforeDestroy")]),t._v(" "),s("td",[s("strong",[t._v("beforeUnmount")])]),t._v(" "),s("td",[t._v("组件实例销毁之前")])]),t._v(" "),s("tr",[s("td",[t._v("destroyed")]),t._v(" "),s("td",[s("strong",[t._v("unmounted")])]),t._v(" "),s("td",[t._v("组件实例销毁之后")])])])]),t._v(" "),s("p",[t._v("其他特殊场景的生命周期：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Vue2")]),t._v(" "),s("th",[t._v("Vue3")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("activated")]),t._v(" "),s("td",[t._v("activated")]),t._v(" "),s("td",[t._v("keep-alive 缓存的组件激活时")])]),t._v(" "),s("tr",[s("td",[t._v("deactivated")]),t._v(" "),s("td",[t._v("deactivated")]),t._v(" "),s("td",[t._v("keep-alive 缓存的组件停用时调用")])]),t._v(" "),s("tr",[s("td",[t._v("errorCaptured")]),t._v(" "),s("td",[t._v("errorCaptured")]),t._v(" "),s("td",[t._v("捕获一个来自子孙组件的错误时被调用")])]),t._v(" "),s("tr",[s("td",[t._v("-")]),t._v(" "),s("td",[s("strong",[t._v("renderTracked")])]),t._v(" "),s("td",[t._v("调试钩子，响应式依赖被收集时调用")])]),t._v(" "),s("tr",[s("td",[t._v("-")]),t._v(" "),s("td",[s("strong",[t._v("renderTriggered")])]),t._v(" "),s("td",[t._v("调试钩子，响应式依赖被触发时调用")])]),t._v(" "),s("tr",[s("td",[t._v("-")]),t._v(" "),s("td",[s("strong",[t._v("serverPrefetch")])]),t._v(" "),s("td",[t._v("ssr only，组件实例在服务器上被渲染前调用")])])])]),t._v(" "),s("p",[t._v("整体流程图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://v3.cn.vuejs.org/images/lifecycle.svg",alt:"实例的生命周期"}})])]),t._v(" "),s("li",[s("p",[t._v("实践：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("beforeCreate")]),t._v("：通常用于插件开发中执行一些初始化任务")]),t._v(" "),s("li",[s("strong",[t._v("created")]),t._v("：组件初始化完毕，可以访问各种数据，获取接口数据等")]),t._v(" "),s("li",[s("strong",[t._v("mounted")]),t._v("：dom已创建，可用于获取访问数据和dom元素；访问子组件等。")]),t._v(" "),s("li",[s("strong",[t._v("beforeUpdate")]),t._v("：此时"),s("code",[t._v("view")]),t._v("层还未更新，可用于获取更新前各种状态")]),t._v(" "),s("li",[s("strong",[t._v("updated")]),t._v("：完成"),s("code",[t._v("view")]),t._v("层的更新，更新后，所有状态已是最新")]),t._v(" "),s("li",[s("strong",[t._v("beforeunmount")]),t._v("：实例被销毁前调用，可用于一些定时器或订阅的取消")]),t._v(" "),s("li",[s("strong",[t._v("unmounted")]),t._v("：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("延申问题")]),s("ul",[s("li",[t._v("setup和created谁先执行？\n"),s("ul",[s("li",[t._v("setup是在props解析之后，beforeCreate执行之前进行调用")]),t._v(" "),s("li",[t._v("如果在setup中和外部同时调用一个生命周期函数，setup的生命周期函数在外部的生命周期函数之前执行")])])]),t._v(" "),s("li",[t._v("setup中为什么没有beforeCreate和created？\n"),s("ul",[s("li",[t._v("因为 "),s("code",[t._v("setup")]),t._v(" 是围绕 "),s("code",[t._v("beforeCreate")]),t._v(" 和 "),s("code",[t._v("created")]),t._v(" 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 "),s("code",[t._v("setup")]),t._v(" 函数中编写。 ——Vue3官网文档")])])])])]),s("h2",{attrs:{id:"六、v-for和v-if优先级哪个高-能放在一起使用吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、v-for和v-if优先级哪个高-能放在一起使用吗"}},[t._v("#")]),t._v(" 六、"),s("code",[t._v("v-for")]),t._v("和"),s("code",[t._v("v-if")]),t._v("优先级哪个高？能放在一起使用吗？")]),t._v(" "),s("p",[t._v("回答思路：先说结论 => 说出细节（为什么） => 哪些场景会导致这样？如何解决 => 总结")]),t._v(" "),s("ul",[s("li",[t._v("不应该放在一起使用。在Vue2和Vue3中表现不一样：\n"),s("ul",[s("li",[t._v("Vue2文档说明："),s("a",{attrs:{href:"https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81",target:"_blank",rel:"noopener noreferrer"}},[t._v("避免"),s("code",[t._v("v-if")]),t._v("和"),s("code",[t._v("v-for")]),t._v("用在一起"),s("OutboundLink")],1),t._v("，"),s("code",[t._v("v-for")]),t._v(" 比 "),s("code",[t._v("v-if")]),t._v(" 具有更高的优先级；")]),t._v(" "),s("li",[t._v("Vue3文档说明："),s("a",{attrs:{href:"https://v3.cn.vuejs.org/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81",target:"_blank",rel:"noopener noreferrer"}},[t._v("避免 "),s("code",[t._v("v-if")]),t._v(" 和 "),s("code",[t._v("v-for")]),t._v(" 一起使用"),s("OutboundLink")],1),t._v("，"),s("code",[t._v("v-if")]),t._v(" 比 "),s("code",[t._v("v-for")]),t._v(" 具有更高的优先级。")])])]),t._v(" "),s("li",[t._v("在Vue2中如果放在一起使用，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；在Vue3中如果放在一起使用，"),s("code",[t._v("v-if")]),t._v("的优先级更高，执行"),s("code",[t._v("v-if")]),t._v("时，它调用的变量还不存在，就会导致异常。")]),t._v(" "),s("li",[t._v("使用场景及解决方法：\n"),s("ul",[s("li",[t._v("场景一："),s("strong",[t._v("过滤列表中的项目")]),t._v("：如 "),s("code",[t._v('v-for="user in users" v-if="user.isActive"')]),t._v(")。解决方式为定义一个计算属性（如 "),s("code",[t._v("activeUsers")]),t._v("），让其返回过滤后的列表即可。")]),t._v(" "),s("li",[t._v("场景二："),s("strong",[t._v("避免渲染本应该被隐藏的列表")]),t._v("：如 "),s("code",[t._v('v-for="user in users" v-if="shouldShowUsers"')]),t._v("。解决方式为把 "),s("code",[t._v("v-if")]),t._v(" 移动至容器元素上 (比如 "),s("code",[t._v("ul")]),t._v("、"),s("code",[t._v("ol")]),t._v(")或者外面包一层"),s("code",[t._v("template")]),t._v("即可。")])])])]),t._v(" "),s("h2",{attrs:{id:"七、v-if和v-show的区别-应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、v-if和v-show的区别-应用场景"}},[t._v("#")]),t._v(" 七、"),s("code",[t._v("v-if")]),t._v("和"),s("code",[t._v("v-show")]),t._v("的区别？应用场景？")]),t._v(" "),s("p",[t._v("回答思路：两者区别 => 原理 => 应用场景 => 总结")]),t._v(" "),s("ul",[s("li",[t._v("两者都可以控制元素是否在屏幕上显示，其原理是：\n"),s("ul",[s("li",[s("code",[t._v("v-if")]),t._v("通过控制节点是否存在来决定是否显示元素（是否渲染节点）")]),t._v(" "),s("li",[s("code",[t._v("v-show")]),t._v("通过设置元素的display属性来控制是否隐藏元素（是否显示）")])])]),t._v(" "),s("li",[t._v("应用场景：\n"),s("ul",[s("li",[s("code",[t._v("v-if")]),t._v("适用于在运行时很少改变条件，不需要频繁切换条件的场景")]),t._v(" "),s("li",[s("code",[t._v("v-show")]),t._v("适用于需要非常频繁切换条件的场景")])])])]),t._v(" "),s("h2",{attrs:{id:"八、能说说key的作用吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#八、能说说key的作用吗"}},[t._v("#")]),t._v(" 八、能说说key的作用吗？")]),t._v(" "),s("p",[t._v("回答思路：给出结论 => 必要性 => 实际使用 => 总结")]),t._v(" "),s("ul",[s("li",[t._v("作用主要是为了更高效的更新虚拟DOM，优化patch的性能；")]),t._v(" "),s("li",[t._v("在patch过程中"),s("strong",[t._v("通过key判断两个节点是否是相同节点是一个必要条件")]),t._v("，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个patch过程比较低效，影响性能。")]),t._v(" "),s("li",[t._v("实际使用中在"),s("strong",[t._v("渲染一组列表时key必须设置，而且必须是唯一标识")]),t._v("，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/vnode.ts#L347",target:"_blank",rel:"noopener noreferrer"}},[t._v("从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等"),s("OutboundLink")],1),t._v("，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。")])]),t._v(" "),s("p",[t._v("下面我举一个小例子，可以看出两种方式需要操作的元素差别：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202205171322859.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"九、watch与computed的区别-应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#九、watch与computed的区别-应用场景"}},[t._v("#")]),t._v(" 九、watch与computed的区别？应用场景？")]),t._v(" "),s("p",[t._v("回答思路：定义上的区别 => 使用与场景上的差别 => 使用细节及注意 => Vue3变化")]),t._v(" "),s("ul",[s("li",[t._v("定义上的区别\n"),s("ul",[s("li",[t._v("computed属性："),s("strong",[t._v("从组件数据派生出新数据")]),t._v("，最常见的使用方式是设置一个函数，返回计算之后的结果，computed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。（会生成computedWatcher）")]),t._v(" "),s("li",[t._v("watch："),s("strong",[t._v("可以侦测某个响应式数据的变化并执行副作用")]),t._v("，常见用法是传递一个函数，执行副作用，watch没有返回值，但可以执行异步操作等复杂逻辑。")])])]),t._v(" "),s("li",[t._v("使用场景对比：\n"),s("ul",[s("li",[t._v("computed常用场景：简化行内模板中的复杂表达式，模板中出现太多逻辑会使模板变得臃肿不易维护；")]),t._v(" "),s("li",[t._v("watch常用场景：状态变化之后做一些额外的DOM操作或者异步操作；")]),t._v(" "),s("li",[t._v("选择采用何用方案时首先看是否需要派生出新值，基本能用计算属性实现的方式首选计算属性。")])])]),t._v(" "),s("li",[t._v("使用过程中有一些细节，比如computed也是可以传递对象，成为既可读又可写的计算属性；watch可以传递对象，设置deep、immediate等选项。")]),t._v(" "),s("li",[t._v("vue3中watch选项发生了一些变化：不再能侦测一个点操作符之外的字符串形式的表达式； reactivity API中新出现了watch、watchEffect可以完全替代目前的watch选项，且功能更加强大。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("延申问题")]),s("ul",[s("li",[t._v("watch会不会立即执行？\n"),s("ul",[s("li",[t._v("不会，watch是惰性执行的，只有监听的值发生变化的时候才会执行")]),t._v(" "),s("li",[t._v("可以设置第三个参数的选项"),s("code",[t._v("immediate: true")]),t._v(" 将立即以表达式的当前值触发回调")])])]),t._v(" "),s("li",[t._v("watch 和 watchEffect有什么差异\n"),s("ul",[s("li",[t._v("watch需要传递监听的对象，watchEffect不需要，会自动追踪依赖（这里是"),s("a",{attrs:{href:"https://www.jianshu.com/p/d9753aff896f",target:"_blank",rel:"noopener noreferrer"}},[t._v("只能监听对象属性"),s("OutboundLink")],1),t._v("）；")]),t._v(" "),s("li",[t._v("watch是惰性执行，watchEffect立即执行传入的一个函数；")]),t._v(" "),s("li",[t._v("watch可以访问状态变化前后的值，watchEffect只是依赖更新时执行函数；")])])]),t._v(" "),s("li",[t._v("computed原理：\n"),s("ul",[s("li",[t._v("初始化computed的时候，会生成computedWatchers，并且将对应的computed属性挂载到vm对象上，获取computed时，触发getter，计算computed的结果，这个过程又会读取computed函数内使用的响应式数据，分别触发这两个响应式数据的getter并进行依赖收集；")])])]),t._v(" "),s("li",[t._v("watcher原理：\n"),s("ul",[s("li",[t._v("初始化的时候指定观测的属性，同时实例化一个watcher对象，在所观测的属性发生变化的时候再执行指定的回调函数。")])])])])]),s("h2",{attrs:{id:"十、nexttick的原理了解吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十、nexttick的原理了解吗"}},[t._v("#")]),t._v(" 十、nextTick的原理了解吗？")]),t._v(" "),s("p",[t._v("回答思路：是什么 => 为什么 => 何时使用，如何使用 => 原理")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fstaging-cn.vuejs.org%2Fapi%2Fgeneral.html%23nexttick",target:"_blank",rel:"noopener noreferrer"}},[t._v("nextTick"),s("OutboundLink")],1),t._v("是等待下一次 DOM 更新刷新的工具方法。")]),t._v(" "),s("li",[t._v("Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick。")]),t._v(" "),s("li",[t._v("使用场景：\n"),s("ul",[s("li",[t._v("created中想要获取DOM时；")]),t._v(" "),s("li",[t._v("响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度。")])])]),t._v(" "),s("li",[t._v("nextTick签名如下："),s("code",[t._v("function nextTick(callback?: () => void): Promise<void>")]),t._v("，所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事。")]),t._v(" "),s("li",[t._v("原理：在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数（"),s("code",[t._v("flushSchedulerQueue")]),t._v("）的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值。")])]),t._v(" "),s("h2",{attrs:{id:"十一、keep-alive组件了解吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十一、keep-alive组件了解吗"}},[t._v("#")]),t._v(" 十一、keep-alive组件了解吗？")]),t._v(" "),s("p",[t._v("keep-alive是缓存组件，是一个非常有用且常见的优化手段。")]),t._v(" "),s("p",[t._v("回答思路：作用与用法 => 使用细节 => 缓存后更新 => 原理")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("keep-alive是vue内置组件，keep-alive包裹动态组件component时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。（"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#keep-alive",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue2官方文档"),s("OutboundLink")],1),t._v("）")]),t._v(" "),s("div",{staticClass:"language-vue line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-vue"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":is")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("view"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("使用细节：结合属性include和exclude可以明确指定缓存哪些组件或排除缓存指定组件；在Vue3中，结合Vue-Router时变化较大，之前是"),s("code",[t._v("keep-alive")]),t._v("包裹"),s("code",[t._v("router-view")]),t._v("，现在需要反过来用"),s("code",[t._v("router-view")]),t._v("包裹"),s("code",[t._v("keep-alive")]),t._v("（"),s("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#keep-alive",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue2官方文档"),s("OutboundLink")],1),t._v("、"),s("a",{attrs:{href:"https://v3.cn.vuejs.org/api/built-in-components.html#keep-alive",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3官方文档"),s("OutboundLink")],1),t._v("）。")]),t._v(" "),s("div",{staticClass:"language-vue line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-vue"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- Vue2 --\x3e")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-view")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-slot")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{ Component }"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-view")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- Vue3 --\x3e")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-view")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-slot")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{ Component }"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":is")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Component"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("keep-alive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-view")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("缓存后更新：；获取数据可以通过路由导航守卫获取，或者通过activated钩子。")])]),t._v(" "),s("li",[s("p",[t._v("keep-alive原理：")]),t._v(" "),s("ul",[s("li",[t._v("直接实现了 "),s("code",[t._v("render")]),t._v(" 函数，获取到它的默认插槽（一般只处理第一个子元素），然后判断include和exclude与组件的关系；")]),t._v(" "),s("li",[t._v("符合include和exclude关系的组件就会看是否命中缓存（内部定义了一个map，根据key来判断），则直接从缓存中拿 "),s("code",[t._v("vnode")]),t._v(" 的组件实例，并且重新调整了 key 的顺序放在了最后一个（LRU算法）；")]),t._v(" "),s("li",[t._v("否则把 "),s("code",[t._v("vnode")]),t._v(" 设置进缓存，最后还有一个逻辑，如果配置了 "),s("code",[t._v("max")]),t._v(" 并且缓存的长度超过了 "),s("code",[t._v("this.max")]),t._v("，还要从缓存中删除第一个，这个删除首先判断是否是当前渲染组件，是的话，还要调用实例的$destroy方法；")]),t._v(" "),s("li",[t._v("由于component的is属性是个响应式数据，因此只要它变化，keep-alive的render函数就会重新执行。")])])])]),t._v(" "),s("h2",{attrs:{id:"十二、说说对vuex的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十二、说说对vuex的理解"}},[t._v("#")]),t._v(" 十二、说说对Vuex的理解")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://vuex.vuejs.org/vuex.png",alt:"vuex"}})]),t._v(" "),s("p",[t._v("回答思路：定义 => 必要性 => 何时使用 => 扩展")]),t._v(" "),s("ul",[s("li",[t._v("Vuex 是一个专为 Vue.js 应用开发的"),s("strong",[t._v("状态管理模式 + 库")]),t._v("。它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")]),t._v(" "),s("li",[t._v("当我们的应用遇到"),s("strong",[t._v("多个组件共享状态")]),t._v("时，单向数据流的简洁性很容易被破坏：多个视图依赖于同一状态；来自不同视图的行为需要变更同一状态。\n"),s("ul",[s("li",[t._v("对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。")]),t._v(" "),s("li",[t._v("因此，把组件的共享状态抽取出来，以一个全局单例模式管理，通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！代码将会变得更结构化且易维护。")])])]),t._v(" "),s("li",[t._v("Vuex 解决状态管理的同时引入了不少概念：例如state、mutation、action等，是否需要引入还需要根据应用的实际情况衡量一下：如果不打算开发大型单页应用，使用 Vuex 反而是繁琐冗余的，一个简单的 "),s("a",{attrs:{href:"https://v3.cn.vuejs.org/guide/state-management.html#%E7%B1%BB-flux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("store 模式"),s("OutboundLink")],1),t._v("就足够了。但是，如果要构建一个中大型单页应用，Vuex 基本是标配。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("问题扩展")]),s("ul",[s("li",[t._v("Vuex的缺点？开发过程中的问题？\n"),s("ul",[s("li",[t._v("刷新浏览器时，状态会恢复到初始状态。我们在项目中做一下本地化存储")])])]),t._v(" "),s("li",[t._v("action和mutation的区别？\n"),s("ul",[s("li",[t._v("Action 提交的是 mutation，而不是直接变更状态；mutation直接变更状态。")]),t._v(" "),s("li",[t._v("Action 可以包含任意异步操作；Mutation必须是同步函数。")])])]),t._v(" "),s("li",[t._v("为什么只能通过mutation改变state？\n"),s("ul",[s("li",[t._v("如果mutation中包含了异步函数，当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用。这会导致状态的改变不可追踪。")])])])])]),s("h2",{attrs:{id:"十三、vue模板编译原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十三、vue模板编译原理"}},[t._v("#")]),t._v(" 十三、Vue模板编译原理")]),t._v(" "),s("p",[t._v("回答思路：模板编译概念 => 编译器的必要性 => 工作流程")]),t._v(" "),s("ul",[s("li",[t._v("Vue中有个独特的编译器模块，称为“compiler”，它的主要作用是将用户编写的template编译为中可执行的render函数。")]),t._v(" "),s("li",[t._v("必要性：为了便于开发人员能高效的编写视图模板，使用HTML编写视图直观且高效。手写render函数不仅效率底下，而且失去了编译期的优化能力。")])]),t._v(" "),s("p",[t._v("工作原理及流程（三步）：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("解析器")]),t._v("parse："),s("strong",[t._v("模板字符串")]),t._v(" 转换成 element "),s("strong",[t._v("ASTs")]),t._v("（HTML解析器、文本解析器、过滤器解析器）\n"),s("ul",[s("li",[t._v("主要的是HTML解析器，解析过程不停触发钩子函数（start、end、chars、comment），这个过程是从前向后解析的，通过维护一个栈来记录层级关系，处理到开始标签就push，处理到结束标签就pop，栈顶元素就是当前处理的元素的父元素。")]),t._v(" "),s("li",[t._v("HTML解析器的解析过程就是循环着一段一段的进行解析，截取片段主要包括：开始标签、结束标签、HTML注释、DOCTYPE、条件注释、文本等。对于开始标签，还有针对标签属性进行处理的逻辑。标签的识别和片段的截取主要依靠正则表达式来完成。")]),t._v(" "),s("li",[t._v("文本解析器对HTML解析器解析出来的文本二次加工，对于纯文本本，直接保存在AST中；对于带变量的文本，将"),s("code",[t._v("{{")]),t._v("前的文本、变量文本生成一个含有"),s("code",[t._v("_s()")]),t._v("的表达式、以及"),s("code",[t._v("}}")]),t._v("后的文本保存在数组中，再通过数组的"),s("code",[t._v("join")]),t._v("方法拼接后保存。")])])]),t._v(" "),s("li",[s("strong",[t._v("优化器")]),t._v("optimize：对ASTs进行"),s("strong",[t._v("静态节点以及静态根节点标记")]),t._v("，主要用来做虚拟DOM的渲染优化\n"),s("ul",[s("li",[t._v("首先是标记所有静态节点：通过递归的方式标记所有的元素节点，如果节点本身是静态节点，但存在非静态子节点，则将自己修改为非静态节点（静态节点判断：文本节点；节点上没有v-bind、v-for、v-if等指令；非组件）；")]),t._v(" "),s("li",[t._v("然后是基于静态节点进一步标记静态根节点：如果节点本身是静态节点 && 有子节点 && 子节点不全是文本节点，则标记为静态根节点。")])])]),t._v(" "),s("li",[s("strong",[t._v("代码生成器")]),t._v("generate：使用 element ASTs "),s("strong",[t._v("生成 render 函数代码字符串")]),t._v(" "),s("ul",[s("li",[t._v("根据节点类型生成相应的字符串："),s("code",[t._v("_c")]),t._v("（元素节点，"),s("code",[t._v("createElement")]),t._v("）、"),s("code",[t._v("_v")]),t._v("（文本节点，"),s("code",[t._v("createTextVNode")]),t._v("）、"),s("code",[t._v("_e")]),t._v("（注释节点，"),s("code",[t._v("createEmptyVNode")]),t._v("）")]),t._v(" "),s("li",[t._v("递归处理，每处理一个AST节点，就生成对应的字符串代码。")]),t._v(" "),s("li",[t._v("字符串拼接完成后，再拼在with中返回给调用者，这样就生成了render函数代码字符串。")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("扩展问题")]),s("ul",[s("li",[t._v("Vue中的编译器何时执行？\n"),s("ul",[s("li",[t._v("编译器执行发生在实例挂载"),s("code",[t._v("$mount")]),t._v("时执行。这里会首先判断options中有无定义了render属性，如果没有，则会通过"),s("code",[t._v("compileToFunctions")]),t._v("函数将template转换为render，再挂载到options上，之后再执行mount方法。")])])]),t._v(" "),s("li",[t._v("react中有没有编译器？")])])]),s("h2",{attrs:{id:"十四、说说对虚拟dom的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十四、说说对虚拟dom的理解"}},[t._v("#")]),t._v(" 十四、说说对虚拟DOM的理解？")]),t._v(" "),s("p",[t._v("回答思路：vDOM是什么 => 好处 => 如何生成？如何转为DOM？ => 在Diff中的作用")]),t._v(" "),s("ul",[s("li",[t._v("虚拟DOM顾名思义就是虚拟的DOM对象，它本身就是一个 JavaScript 对象，只不过它是通过不同的属性去描述一个视图结构。")]),t._v(" "),s("li",[t._v("好处是：\n"),s("ul",[s("li",[s("strong",[t._v("将真实元素节点抽象成 VNode，有效减少直接操作 DOM 次数，从而提高程序性能")]),t._v("：一个真实元素上有许多的内容，如果直接对其进行 Diff 操作，会去额外 Diff 一些没有必要的内容；如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的，但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。另外，操作 DOM 是比较昂贵的操作，频繁的 DOM 操作容易引起页面的重绘和回流，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作 DOM 的次数，从而减少页面重绘和回流。")]),t._v(" "),s("li",[s("strong",[t._v("方便实现跨平台")]),t._v("：同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 DOM 元素节点，渲染在 Native（iOS、Android）变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等。在Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以针对不同平台进行渲染。")])])]),t._v(" "),s("li",[t._v("vDOM如何生成？如何转为DOM？：我们在Vue开发时为组件编写模板template， 这个模板会被编译器compiler编译为渲染函数render，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟DOM。但它们还不是真正的DOM，所以会在后续的patch过程中进一步转化为DOM。")]),t._v(" "),s("li",[t._v("在Diff中的作用：挂载过程结束后，Vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的vDOM，和上一次的渲染结果进行Diff，就能得到变化的地方，从而转换为最小量的DOM操作，高效更新视图。")])]),t._v(" "),s("h2",{attrs:{id:"十五、了解diff算法吗-如何做patch更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十五、了解diff算法吗-如何做patch更新"}},[t._v("#")]),t._v(" 十五、了解Diff算法吗？如何做patch更新？")]),t._v(" "),s("p",[t._v("回答思路：算法的作用 => 必要性 => 执行时机 => 具体执行方式")]),t._v(" "),s("ul",[s("li",[t._v("Vue中的Diff算法称为patching算法，主要用作将虚拟DOM转换为真实DOM。")]),t._v(" "),s("li",[t._v("Vue1中每引用一次响应式数据，就会生成一个 watcher，可以做到精确更新，因此并不需要虚拟DOM和patching算法，但是这样不适用于大型应用场景；Vue2则是一个组件一个watcher，粒度降低了，提高了更新效率，但无法知道更新的数据在组件的什么位置，因此需要patching算法找到变化的位置并高效更新。")]),t._v(" "),s("li",[t._v("patching的发生时刻是：初次渲染或者组件内响应式数据变化导致组件更新，触发实例执行update更新函数，再次执行了render函数获得了最新的虚拟DOM，然后执行patch函数，传入新旧两次虚拟DOM，通过对比找出变化的地方，转化为对应的最新的DOM。")])]),t._v(" "),s("p",[t._v("具体执行方式（"),s("strong",[t._v("深度优先、同层比较")]),t._v("）：")]),t._v(" "),s("ul",[s("li",[t._v("新vnode不存在，老vnode存在，调用 destroy，销毁老节点")]),t._v(" "),s("li",[t._v("新vnode存在，老vnode不存在，表示首次渲染，用vnode创建新节点；或者两者完全不是同一个节点，也要创建新节点")]),t._v(" "),s("li",[t._v("新vnode存在，老vnode存在，并且两者是同一个节点，表示更新，执行patchVnode更新节点（patchVnode过程见下图）\n"),s("ul",[s("li",[t._v("如果新老vnode相同，或者是静态节点，则退出更新")]),t._v(" "),s("li",[t._v("对新vnode的节点属性进行全量更新")]),t._v(" "),s("li",[t._v("如果双方都是文本节点，则更新文本节点内容")]),t._v(" "),s("li",[t._v("否则对比更新双方的子节点，因为前端很少有完全打乱节点顺序的情况，这里首先做了四种假设：新老start相同、新老end相同、新end老start相同、新start老end相同，一旦命中假设，就避免了一次循环；如果没有命中假设，则执行遍历，从老的 VNode 中找到新的 VNode 的开始节点。找到节点后继续执行patchVnode（递归）。遍历结束后，如果新vnode剩下，则新增这些孩子节点，如果老vnode剩下，则删除这些孩子节点。")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202205182044332.png",alt:""}})]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("延申问题")]),s("ul",[s("li",[t._v("引入虚拟DOM后渲染过程真的快了吗？\n"),s("ul",[s("li",[t._v("这个我认为是大部分场景下是变快了，而一小部分场景下是会变慢的，框架提供虚拟DOM除了跨平台与可维护性外，可以在不手动优化的情况下，依然提供一个较为不错的性能。而且，在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合， Virtual DOM 不一定就是快，Diff 不是免费的，Virtual DOM 真正的价值从来都不是性能，而是它（1）为函数式的 UI 编程方式打开了大门；（2）可以渲染到 DOM 以外的 backend，比如 ReactNative。")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.zhihu.com/question/31809713/answer/53544875",target:"_blank",rel:"noopener noreferrer"}},[t._v("尤大回答知乎提问：网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？"),s("OutboundLink")],1)])])]),t._v(" "),s("li",[t._v("Diff的时间复杂度是多少？树的遍历对比为什么可以降低到这个时间复杂度？\n"),s("ul",[s("li",[s("code",[t._v("O(n)")]),t._v("，查找两棵树的差异，需要"),s("code",[t._v("O(n^2)")]),t._v("，找到差异后还要计算最小转换方式，最总结果为"),s("code",[t._v("O(n^3)")]),t._v("。而Diff算法则采用同层比较的策略，如果一方的节点不存在，则添加或删除，如果双方节点不同则更新，这样的话，只要遍历一遍所有节点即可。")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/151",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？"),s("OutboundLink")],1)])])])])]),s("p",[t._v("Vue3 的patch优化：")]),t._v(" "),s("ul",[s("li",[t._v("引入patchFlag，并不是全量更新节点属性，而是根据其FULL_PROPS、CLASS、PROPS、TEXT等属性做更新，优化更新节点属性的过程；")]),t._v(" "),s("li",[t._v("更新子节点patchChildren时，同样使用patchFlag和shapeFlag（元素类型标记）来进行优化，不同的类型调用不同的path函数；在调用patchKeyedChildren 对新旧子节点进行完整diff的过程与Vue2差不多了。")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.jianshu.com/p/abd46fb77ec8",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3 Patch 算法"),s("OutboundLink")],1),t._v("，"),s("a",{attrs:{href:"https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/renderer.ts#L354",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3源码"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"十六、vuex原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十六、vuex原理"}},[t._v("#")]),t._v(" 十六、Vuex原理")]),t._v(" "),s("p",[t._v("回答思路：介绍Vuex及使用 => 原理解析 => 新版本的实现")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Vuex是专门为Vuejs应用程序设计的"),s("strong",[t._v("状态管理模式 + 库")]),t._v("。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex的使用首先需要经过Vue的插件机制安装，然后实例化store时调用install方法，最后注入store挂载Vue实例。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" Vuex "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vuex'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nVue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("use")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Vuex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. vue的插件机制，安装vuex")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" store "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vuex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Store")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2.实例化store，调用install方法")]),t._v("\n    state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" getters"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" modules"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mutations"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" actions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" plugins\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3.注入store, 挂载vue实例")]),t._v("\n    store"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("h")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("h")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("app"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$mount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#app'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("原理解析")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("store挂载注入到组件中")]),t._v("：主要利用了Vue的插件机制，使用"),s("code",[t._v("Vue.use()")]),t._v("方法时调用Vuex中定义的install方法装载Vuex，里面又使用了Vue的混入机制，在beforeCreate钩子函数前混入vuexInit方法，注册"),s("code",[t._v("$store")]),t._v("属性；")]),t._v(" "),s("li",[s("strong",[t._v("state和getters映射到各个组件实例中响应式更新状态")]),t._v("：state响应式的实现是借助Vue的data的响应式，将state存入Vue实例组件的data中；getters则是借助Vue的计算属性computed实现数据实时监听。")])])]),t._v(" "),s("li",[s("p",[t._v("Vuex4兼容Vuex3，原理解析：")]),t._v(" "),s("ul",[s("li",[t._v("新版本则更换为provide和inject来将store注入到Vue实例中，具体说就是，在安装插件的install方法中provide，在使用store的组件中使用useStore方法，里面调用了inject方法，通过原型链找到父级实例的provide的属性，这样就将store混入了；通过发布订阅模式实现mutation和actions。")]),t._v(" "),s("li",[t._v("响应式状态更新实现则通过Vue3的reactive实现。")])])])]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("参考链接")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/78981485",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vuex从使用到原理解析"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/u012384510/article/details/117236566",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文读懂vuex4源码，原来provide/inject就是妙用了原型链?"),s("OutboundLink")],1)])])]),t._v(" "),s("h2",{attrs:{id:"十七、vue-router原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十七、vue-router原理"}},[t._v("#")]),t._v(" 十七、Vue-Router原理")]),t._v(" "),s("p",[t._v("回答思路：路由 => 前端路由模式 => 原理解析（如何实现）")]),t._v(" "),s("ul",[s("li",[t._v("后端路由与前端路由\n"),s("ul",[s("li",[t._v("后端路由是浏览器请求URL来获取静态资源或者对数据进行操作（增删改查），利于SEO且安全性高，但代码耦合度高，存在服务器压力且HTTP请求受限于网络环境，影响用户体验；")]),t._v(" "),s("li",[t._v("前端路由是SPA使得页面组件化，实现页面的局部刷新。优点是组件切换不需要发送HTTP请求，切换跳转快，用户体验好；缺点是没有合理的利用缓存且不利于SEO。")])])]),t._v(" "),s("li",[t._v("前端路由的hash模式和history模式\n"),s("ul",[s("li",[t._v("hash模式是默认模式，域名后带有"),s("code",[t._v("#")]),t._v("，通过"),s("code",[t._v("location.hash")]),t._v("获取当前URL的hash值，通过"),s("code",[t._v("hashChange")]),t._v("监听URL中的hash改变。这个模式兼容性好，hash变化会在浏览器history中留下记录以实现前进后退功能。")]),t._v(" "),s("li",[t._v("history模式基于H5的history对象，通过"),s("code",[t._v("location.pathname")]),t._v("获取到当前URL的路由地址，通过"),s("code",[t._v("pushState")]),t._v("和"),s("code",[t._v("replaceState")]),t._v("方法可以修改URL地址，结合"),s("code",[t._v("popstate")]),t._v("方法监听URL中路由的变化。这个模式可读性更强，URL更美观，但刷新或手动输入地址的时候会向服务器发送请求，需要后端做重定向。")])])]),t._v(" "),s("li",[t._v("Vue-Router的使用也跟Vuex差不多，先要经过Vue的插件机制安装，然后实例化vueRouter，最后注入router挂载到Vue实例。\n"),s("ul",[s("li",[s("strong",[t._v("router挂载注入到组件中")]),t._v("：实现一个install方法，里面通过"),s("code",[t._v("Vue.mixin")]),t._v("混入beforeCreate生命周期钩子，通过Vue实例暴露的工具方法"),s("code",[t._v("defineReactive")]),t._v("将"),s("code",[t._v("currentRoute")]),t._v("属性变成一个监视者；同时定义"),s("code",[t._v("$router")]),t._v("和"),s("code",[t._v("$route")]),t._v("两个属性，通过"),s("code",[t._v("Object.defineProperty")]),t._v("代理属性并让其只读，这样Vue组件实例都能访问到路由相关属性；")]),t._v(" "),s("li",[s("strong",[t._v("渲染")]),t._v("：currentRoute表示的就是当前路由，当路由变化的时候可以获取到最新的路由地址和路由表，这个时候找出对应的组件然后交给router-view组件的渲染函数即可；根据模式不同监听的事件不同，hash模式监听"),s("code",[t._v("hashchange")]),t._v("事件，history模式监听"),s("code",[t._v("popstate")]),t._v("事件；")]),t._v(" "),s("li",[s("strong",[t._v("路由跳转实现")]),t._v("：history模式下, 路由切换通过"),s("code",[t._v("history.pushState")]),t._v("方法完成；在hash模式下，路由的切换是直接通过hash值的变化来实现；")])])])]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("参考链接")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6844904169954869262",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue-router原理及其核心功能实现"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://github1s.com/vuejs/router/blob/vue2/src/index.ts#L25",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue-Router源码阅读"),s("OutboundLink")],1)])])]),t._v(" "),s("h2",{attrs:{id:"场景-如何扩展一个组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景-如何扩展一个组件"}},[t._v("#")]),t._v(" 场景：如何扩展一个组件？")]),t._v(" "),s("p",[t._v("思路：")]),t._v(" "),s("ul",[s("li",[t._v("按照逻辑扩展和内容扩展来列举，\n"),s("ul",[s("li",[t._v("逻辑扩展有：mixins、extends、composition API；")]),t._v(" "),s("li",[t._v("内容扩展有slots；")])])]),t._v(" "),s("li",[t._v("分别说出他们使用方法、场景差异和问题。")]),t._v(" "),s("li",[t._v("作为扩展，还可以说说Vue3中新引入的composition API带来的变化")])]),t._v(" "),s("p",[t._v("回答：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("常见的组件扩展方法：mixins，slots，extends等")])]),t._v(" "),s("li",[s("p",[t._v("mixins选项是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 复用代码：它是一个配置对象，选项和组件里面一样")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mymixin "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   methods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dosomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 全局混入：将混入对象传入")]),t._v("\nVue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mixin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mymixin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 局部混入：做数组项设置到mixins选项，仅作用于当前组件")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Comp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   mixins"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mymixin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("slots主要用于vue组件中的内容分发，也可用于组件扩展。如果要精确分发到不同位置可使用具名插槽；如果要使用子组件中的数据可使用作用域插槽。")])]),t._v(" "),s("li",[s("p",[t._v("extends选项也可以起到扩展组件的目的：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 扩展对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" myextends "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   methods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dosomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 跟混入不同, 它只能扩展单个对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 另外如果和混入发生冲突，该选项优先级较高，优先起作用")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Comp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" myextends\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("混入的数据和方法"),s("strong",[t._v("不能明确判断来源")]),t._v("且可能和当前组件内变量"),s("strong",[t._v("产生命名冲突")]),t._v("，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中组合使用，增强代码的可读性和维护性。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 复用逻辑1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useXX")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 复用逻辑2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useYY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 逻辑组合")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Comp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setup")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" xx "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useXX")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" yy "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useYY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" yy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("问题扩展")]),s("p",[s("code",[t._v("Vue.extend")]),t._v("方法用过吗？能做组件扩展吗？")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Vue.extend")]),t._v("使用基础 Vue 构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中data选项必须是一个函数。")]),t._v(" "),s("li",[t._v("这个子类是扩展实例构造器，也就是预设了部分选项的Vue实例构造器。其主要用来服务于"),s("code",[t._v("Vue.component")]),t._v("，用来生成组件。可以简单的理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用扩展实例构造器来生产组件实例，并挂载到自定义元素上。")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.jianshu.com/p/e4fed2ce4db1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue.extend实现全局动态组件"),s("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=v.exports}}]);