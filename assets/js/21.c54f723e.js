(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{579:function(v,_,t){"use strict";t.r(_);var i=t(10),o=Object(i.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("内容概览：")]),v._v(" "),t("ul",[t("li",[v._v("HTTP 基本概念")]),v._v(" "),t("li",[v._v("Get 与 Post")]),v._v(" "),t("li",[v._v("HTTP 特性")]),v._v(" "),t("li",[v._v("HTTP 缓存技术")]),v._v(" "),t("li",[v._v("HTTPS 与 HTTP")]),v._v(" "),t("li",[v._v("HTTP/1.1、HTTP/2、HTTP/3 演变")])]),v._v(" "),t("h2",{attrs:{id:"能否详细解释http协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#能否详细解释http协议"}},[v._v("#")]),v._v(" 能否详细解释HTTP协议？")]),v._v(" "),t("p",[v._v("HTTP 是超文本传输协议，也就是"),t("strong",[v._v("H")]),v._v("yperText "),t("strong",[v._v("T")]),v._v("ransfer "),t("strong",[v._v("P")]),v._v("rotocol。可以拆成三个部分：超文本、传输、协议。")]),v._v(" "),t("ul",[t("li",[v._v("超文本：就是"),t("strong",[v._v("超越了普通文本的文本")]),v._v("，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。")]),v._v(" "),t("li",[v._v("传输：把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点；在计算机世界里专门用来在"),t("strong",[v._v("两点之间传输数据")]),v._v("的约定和规范")]),v._v(" "),t("li",[v._v("协议：使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（"),t("strong",[v._v("两个以上的参与者")]),v._v("），以及相关的各种控制和错误处理方式（"),t("strong",[v._v("行为约定和规范")]),v._v("）。")])]),v._v(" "),t("p",[v._v("因此："),t("strong",[v._v("HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。")])]),v._v(" "),t("h2",{attrs:{id:"说一说常见的状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说常见的状态码"}},[v._v("#")]),v._v(" 说一说常见的状态码")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202206081653123.png"}}),v._v(" "),t("ul",[t("li",[v._v("「"),t("strong",[v._v("200 OK")]),v._v("」是最常见的成功状态码，表示一切正常。如果是非 "),t("code",[v._v("HEAD")]),v._v(" 请求，服务器返回的响应头都会有 body 数据。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("204 No Content")]),v._v("」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("206 Partial Content")]),v._v("」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("301 Moved Permanently")]),v._v("」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("302 Found")]),v._v("」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("304 Not Modified")]),v._v("」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("400 Bad Request")]),v._v("」表示客户端请求的报文有错误，但只是个笼统的错误。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("403 Forbidden")]),v._v("」表示服务器禁止访问资源，并不是客户端的请求出错。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("404 Not Found")]),v._v("」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("500 Internal Server Error")]),v._v("」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("501 Not Implemented")]),v._v("」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("502 Bad Gateway")]),v._v("」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。")]),v._v(" "),t("li",[v._v("「"),t("strong",[v._v("503 Service Unavailable")]),v._v("」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。")])]),v._v(" "),t("h2",{attrs:{id:"http-常见字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-常见字段"}},[v._v("#")]),v._v(" HTTP 常见字段")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Host")]),v._v(" 字段：客户端发送请求时，用来"),t("u",[v._v("指定服务器的域名")]),v._v("。")]),v._v(" "),t("li",[t("strong",[v._v("Content-Length")]),v._v(" 字段：服务器在返回数据时，会有 "),t("code",[v._v("Content-Length")]),v._v(" 字段，"),t("u",[v._v("表明本次回应的数据长度")]),v._v("。后面的字节就属于下一个回应了。")]),v._v(" "),t("li",[t("strong",[v._v("Connection")]),v._v(" 字段：最常用于"),t("u",[v._v("客户端要求服务器使用 TCP 持久连接")]),v._v("，以便其他请求复用。如"),t("code",[v._v("Connection: keep-alive")]),v._v("。")]),v._v(" "),t("li",[t("strong",[v._v("Content-Type")]),v._v(" 字段：用于服务器回应时，告诉客户端，本次"),t("u",[v._v("数据是什么格式")]),v._v("。如："),t("code",[v._v("Content-Type: text/html; charset=utf-8")]),v._v("。客户端在请求时，用 "),t("code",[v._v("Accept")]),v._v(" 字段声明自己可以接受哪些数据格式。")]),v._v(" "),t("li",[t("strong",[v._v("Content-Encoding")]),v._v(" 字段：说明数据的压缩方法。表示服务器返回的数据"),t("u",[v._v("使用了什么压缩格式")]),v._v("。如"),t("code",[v._v("Content-Encoding: gzip")]),v._v("。客户端在请求时，用 "),t("code",[v._v("Accept-Encoding")]),v._v(" 字段说明自己可以接受哪些压缩方法。")])]),v._v(" "),t("h2",{attrs:{id:"get与post的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get与post的区别"}},[v._v("#")]),v._v(" GET与POST的区别？")]),v._v(" "),t("ul",[t("li",[v._v("从功能上：\n"),t("ul",[t("li",[v._v("GET 是从服务器上获取数据。")]),v._v(" "),t("li",[v._v("POST 是向服务器发送数据。")])])]),v._v(" "),t("li",[v._v("从过程上：\n"),t("ul",[t("li",[v._v("GET 是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。")]),v._v(" "),t("li",[v._v("POST 是通过HTTP POST 机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。")])])]),v._v(" "),t("li",[v._v("从获取值上：\n"),t("ul",[t("li",[v._v("GET 方式：服务端用 Request.QueryString 获取变量的值")]),v._v(" "),t("li",[v._v("POST 方式：服务端用 Request.Form 获取提交的数据")])])]),v._v(" "),t("li",[v._v("从传送的数据量上：\n"),t("ul",[t("li",[v._v("GET 传送的数据量有限，参数存在于URL中，而URL长度有限制，不能大于2KB。")]),v._v(" "),t("li",[v._v("POST 传送的数据量较大，一般被默认为不受限制。")])])]),v._v(" "),t("li",[v._v("从安全上：\n"),t("ul",[t("li",[t("strong",[v._v("GET 方法就是安全且幂等的")]),v._v("，GET是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。")]),v._v(" "),t("li",[t("strong",[v._v("POST")]),v._v(" 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是"),t("strong",[v._v("不安全")]),v._v("的，且多次提交数据就会创建多个资源，所以"),t("strong",[v._v("不是幂等")]),v._v("的。")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("安全和幂等：")]),v._v(" "),t("ul",[t("li",[v._v("在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。")]),v._v(" "),t("li",[v._v("所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。")])])]),v._v(" "),t("p",[v._v("扩展问题：GET 请求可以带 body 吗？")]),v._v(" "),t("ul",[t("li",[v._v("RFC 规范并没有规定 GET 请求不能带 body 的。")]),v._v(" "),t("li",[v._v("理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。")]),v._v(" "),t("li",[v._v("另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。")])]),v._v(" "),t("h2",{attrs:{id:"http缓存有哪些实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http缓存有哪些实现方式"}},[v._v("#")]),v._v(" HTTP缓存有哪些实现方式？")]),v._v(" "),t("ul",[t("li",[v._v("强制缓存")]),v._v(" "),t("li",[v._v("协商缓存")])]),v._v(" "),t("h3",{attrs:{id:"强制缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[v._v("#")]),v._v(" 强制缓存：")]),v._v(" "),t("p",[v._v("强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。")]),v._v(" "),t("p",[v._v("强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("Cache-Control")]),v._v("， 是一个相对时间；优先级高于"),t("code",[v._v("Expires")]),v._v("；（HTTP1.1）")]),v._v(" "),t("li",[t("code",[v._v("Expires")]),v._v("，是一个绝对时间；（HTTP1.0）")])]),v._v(" "),t("p",[v._v("Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：")]),v._v(" "),t("ul",[t("li",[v._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；")]),v._v(" "),t("li",[v._v("浏览器再次请求访问服务器中的该资源时，会先"),t("strong",[v._v("通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期")]),v._v("，如果没有，则使用该缓存，否则重新请求服务器；")]),v._v(" "),t("li",[v._v("服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。")])]),v._v(" "),t("h3",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存：")]),v._v(" "),t("p",[v._v("所谓协商缓存，就是说"),t("strong",[v._v("客户端与服务端协商之后，通过协商结果来判断是否使用本地缓存")]),v._v("。（用到了 304 状态码）")]),v._v(" "),t("p",[v._v("协商缓存可以基于两种头部来实现：")]),v._v(" "),t("ul",[t("li",[v._v("请求头的"),t("code",[v._v("If-Modified-Since")]),v._v("和响应头的"),t("code",[v._v("Last-Modified")]),v._v("字段：\n"),t("ul",[t("li",[v._v("响应头的"),t("code",[v._v("Last-Modified")]),v._v("：标示这个响应资源的最后修改时间；")]),v._v(" "),t("li",[v._v("请求头的"),t("code",[v._v("If-Modified-Since")]),v._v("：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。")])])]),v._v(" "),t("li",[v._v("请求头的"),t("code",[v._v("If-None-Match")]),v._v("和响应头的"),t("code",[v._v("ETag")]),v._v("：\n"),t("ul",[t("li",[v._v("响应头部中 "),t("code",[v._v("Etag")]),v._v("：唯一标识响应资源；")]),v._v(" "),t("li",[v._v("请求头部中的 "),t("code",[v._v("If-None-Match")]),v._v("：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。")])])])]),v._v(" "),t("p",[v._v("第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。")]),v._v(" "),t("p",[v._v("如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， "),t("strong",[v._v("Etag 的优先级更高")]),v._v("，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。")]),v._v(" "),t("p",[v._v("注意，"),t("strong",[v._v("协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有"),t("u",[v._v("在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求")])]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202206091641285.png",alt:""}})]),v._v(" "),t("h2",{attrs:{id:"http-1-1-2-3-的演变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-2-3-的演变"}},[v._v("#")]),v._v(" HTTP 1.1 / 2 / 3 的演变")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202206101505009.png",alt:""}})]),v._v(" "),t("h3",{attrs:{id:"http1-1-的变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-的变化"}},[v._v("#")]),v._v(" HTTP1.1 的变化：")]),v._v(" "),t("ul",[t("li",[v._v("使用"),t("strong",[v._v("长连接")]),v._v("的方式改善了 HTTP/1.0 短连接造成的性能开销。")]),v._v(" "),t("li",[v._v("支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以"),t("strong",[v._v("减少整体的响应时间")]),v._v("。")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 "),t("code",[v._v("Body")]),v._v(" 的部分；发送冗长的首部。每次互相发送相同的首部造成的浪费较多；")]),v._v(" "),t("li",[v._v("服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；")]),v._v(" "),t("li",[v._v("没有请求优先级控制；")]),v._v(" "),t("li",[v._v("请求只能从客户端开始，服务器只能被动响应。")])]),v._v(" "),t("h3",{attrs:{id:"http2-的变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2-的变化"}},[v._v("#")]),v._v(" HTTP2 的变化：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("头部压缩")]),v._v("：\n"),t("ul",[t("li",[v._v("使用 "),t("code",[v._v("HPACK")]),v._v(" 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就"),t("strong",[v._v("提高速度")]),v._v("了。")])])]),v._v(" "),t("li",[t("strong",[v._v("二进制分帧")]),v._v("：\n"),t("ul",[t("li",[v._v("不再采用纯文本格式的报文，全面采用"),t("strong",[v._v("二进制格式")]),v._v("；")]),v._v(" "),t("li",[v._v("头信息和数据体都是二进制，并且统称为帧（frame）："),t("strong",[v._v("头信息帧（Headers Frame）和数据帧（Data Frame）")]),v._v("；")])])]),v._v(" "),t("li",[t("strong",[v._v("数据流")]),v._v("：\n"),t("ul",[t("li",[v._v("每个请求或相应的所有数据包称为一个数据流（"),t("code",[v._v("Stream")]),v._v("），"),t("strong",[v._v("不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）")]),v._v("；")]),v._v(" "),t("li",[v._v("每个数据流都标记着一个独一无二的编号（Stream ID），每个帧头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息；")]),v._v(" "),t("li",[v._v("客户端和服务器"),t("strong",[v._v("双方都可以建立 Stream")]),v._v("， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。")]),v._v(" "),t("li",[v._v("客户端还可以"),t("strong",[v._v("指定数据流的优先级")]),v._v("。优先级高的请求，服务器就先响应该请求。")])])]),v._v(" "),t("li",[t("strong",[v._v("多路复用")]),v._v("：\n"),t("ul",[t("li",[v._v("可以在"),t("strong",[v._v("一个连接中并发多个请求或回应，而不用按照顺序一一对应")]),v._v("，不需要排队等待，也就不会再出现「队头阻塞」问题，"),t("strong",[v._v("降低了延迟，大幅度提高了连接的利用率")]),v._v("。")])])]),v._v(" "),t("li",[t("strong",[v._v("服务器推送")]),v._v("：\n"),t("ul",[t("li",[v._v("服务端不再是被动地响应，可以"),t("strong",[v._v("主动")]),v._v("向客户端发送消息。")]),v._v(" "),t("li",[v._v("如：客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。")])])])]),v._v(" "),t("p",[v._v("HTTP 2 的缺陷：")]),v._v(" "),t("ul",[t("li",[v._v("仍存在“队头阻塞”问题，但不是在HTTP层，而是在TCP层。")]),v._v(" "),t("li",[t("strong",[v._v("HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。")])]),v._v(" "),t("li",[v._v("一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的"),t("strong",[v._v("所有的 HTTP 请求都必须等待这个丢了的包被重传回来")]),v._v("。")])]),v._v(" "),t("h3",{attrs:{id:"http3-的变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http3-的变化"}},[v._v("#")]),v._v(" HTTP3 的变化")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("把 HTTP 下层的 TCP 协议改成了 UDP")]),v._v("！采用基于 UDP 的 "),t("strong",[v._v("QUIC 协议")]),v._v(" 实现类似 TCP 的可靠性传输。具有以下特点：")]),v._v(" "),t("li",[t("strong",[v._v("无队头阻塞")]),v._v("：\n"),t("ul",[t("li",[v._v("QUIC 有自己的一套机制可以保证传输的可靠性的。"),t("strong",[v._v("当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题")]),v._v("。多个 Stream 之间并没有依赖，都是独立的。")])])]),v._v(" "),t("li",[t("strong",[v._v("建立连接更快速")]),v._v("：\n"),t("ul",[t("li",[v._v("对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。")]),v._v(" "),t("li",[v._v("HTTP/3 在传输数据前虽然需要 QUIC 协议握手，协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，加上使用的是TLS1.3，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。")])])]),v._v(" "),t("li",[t("strong",[v._v("连接迁移")]),v._v("：\n"),t("ul",[t("li",[v._v("基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，"),t("strong",[v._v("当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接")]),v._v("。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。")]),v._v(" "),t("li",[v._v("QUIC 通过"),t("strong",[v._v("连接 ID")]),v._v("来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了"),t("strong",[v._v("连接迁移")]),v._v("的功能。")])])])]),v._v(" "),t("h2",{attrs:{id:"http与https的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[v._v("#")]),v._v(" HTTP与HTTPS的区别")]),v._v(" "),t("ol",[t("li",[v._v("安全：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。")]),v._v(" "),t("li",[v._v("连接：HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。")]),v._v(" "),t("li",[v._v("端口：HTTP 的端口号是 80，HTTPS 的端口号是 443。")]),v._v(" "),t("li",[v._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。")])]),v._v(" "),t("h2",{attrs:{id:"https-解决了-http-的哪些问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-解决了-http-的哪些问题"}},[v._v("#")]),v._v(" HTTPS 解决了 HTTP 的哪些问题？")]),v._v(" "),t("ul",[t("li",[v._v("HTTP"),t("strong",[v._v("不加密")]),v._v("，需要"),t("strong",[v._v("解决窃听风险")]),v._v("：采用"),t("strong",[v._v("混合加密")]),v._v("的方式实现数据的机密性。")]),v._v(" "),t("li",[v._v("HTTP"),t("strong",[v._v("不完整")]),v._v("，需要"),t("strong",[v._v("解决纂改风险")]),v._v("：使用"),t("strong",[v._v("摘要算法+数字签名")]),v._v("，校验数据的完整性。")]),v._v(" "),t("li",[v._v("HTTP"),t("strong",[v._v("不验证")]),v._v("，需要"),t("strong",[v._v("解决冒充风险")]),v._v("：采用"),t("strong",[v._v("数字证书")]),v._v("，解决冒充风险。")])]),v._v(" "),t("h2",{attrs:{id:"https为什么采用混合加密方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https为什么采用混合加密方式"}},[v._v("#")]),v._v(" HTTPS为什么采用混合加密方式")]),v._v(" "),t("p",[v._v("混合加密即采用"),t("strong",[v._v("对称加密")]),v._v("和"),t("strong",[v._v("非对称加密")]),v._v("结合的「混合加密」方式：")]),v._v(" "),t("ul",[t("li",[v._v("在通信建立前采用"),t("strong",[v._v("非对称加密")]),v._v("的方式交换「会话秘钥」；")]),v._v(" "),t("li",[v._v("在通信过程中全部使用"),t("strong",[v._v("对称加密")]),v._v("的「会话秘钥」的方式加密明文数据。")])]),v._v(" "),t("p",[v._v("为什么要采用混合加密的方式：")]),v._v(" "),t("ul",[t("li",[v._v("为了计算效率：\n"),t("ul",[t("li",[v._v("对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换；")]),v._v(" "),t("li",[v._v("非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。")])])]),v._v(" "),t("li",[v._v("为了安全，数据不被纂改：\n"),t("ul",[t("li",[v._v("用"),t("strong",[v._v("摘要算法（哈希函数）"),t("strong",[v._v("来计算出内容的哈希值，可以确保内容不会被篡改；但")]),v._v("不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明")]),v._v("。")]),v._v(" "),t("li",[v._v("采用非对称加密算法可以解决这个问题（公钥+私钥）：\n"),t("ul",[t("li",[t("strong",[v._v("公钥加密，私钥解密")]),v._v("。这个目的是为了"),t("strong",[v._v("保证内容传输的安全")]),v._v("，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；")]),v._v(" "),t("li",[t("strong",[v._v("私钥加密，公钥解密")]),v._v("。这个目的是为了"),t("strong",[v._v("保证消息不会被冒充")]),v._v("，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。")])])])])])]),v._v(" "),t("p",[v._v("一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。所以非对称加密的用途主要在于"),t("strong",[v._v("通过「私钥加密，公钥解密」的方式，来确认消息的身份")]),v._v("，我们常说的"),t("strong",[v._v("数字签名算法")]),v._v("，就是用的是这种方式，不过私钥加密内容不是内容本身，而是"),t("strong",[v._v("对内容的哈希值加密")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"https建立连接的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https建立连接的过程"}},[v._v("#")]),v._v(" HTTPS建立连接的过程？")]),v._v(" "),t("p",[v._v("SSL/TLS 的「握手阶段」涉及"),t("strong",[v._v("四次")]),v._v("通信：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202206101558732.png",alt:""}})]),v._v(" "),t("p",[t("strong",[v._v("（1）ClientHello")])]),v._v(" "),t("p",[v._v("首先，由客户端向服务器发起加密通信请求，也就是 "),t("code",[v._v("ClientHello")]),v._v(" 请求。在这一步，客户端主要向服务器发送以下信息：")]),v._v(" "),t("ol",[t("li",[v._v("客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。")]),v._v(" "),t("li",[v._v("客户端生产的"),t("u",[v._v("随机数")]),v._v("（"),t("code",[v._v("Client Random")]),v._v("），后面用于生成「会话秘钥」条件之一。")]),v._v(" "),t("li",[v._v("客户端支持的"),t("u",[v._v("密码套件列表")]),v._v("，如 RSA 加密算法。")])]),v._v(" "),t("p",[t("strong",[v._v("（2）SeverHello")])]),v._v(" "),t("p",[v._v("服务器收到客户端请求后，向客户端发出响应，也就是 "),t("code",[v._v("SeverHello")]),v._v("。服务器回应的内容有如下内容：")]),v._v(" "),t("ol",[t("li",[v._v("确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。")]),v._v(" "),t("li",[v._v("服务器生产的"),t("u",[v._v("随机数")]),v._v("（"),t("code",[v._v("Server Random")]),v._v("），也是后面用于生产「会话秘钥」条件之一。")]),v._v(" "),t("li",[v._v("确认的"),t("u",[v._v("密码套件列表")]),v._v("，如 RSA 加密算法。")]),v._v(" "),t("li",[v._v("服务器的"),t("u",[v._v("数字证书")]),v._v("。")])]),v._v(" "),t("p",[t("strong",[v._v("（3）客户端回应")])]),v._v(" "),t("p",[v._v("客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会"),t("strong",[v._v("从数字证书中取出服务器的公钥")]),v._v("，然后使用它加密报文，向服务器发送如下信息：")]),v._v(" "),t("ol",[t("li",[v._v("一个随机数（"),t("code",[v._v("pre-master key")]),v._v("）。该随机数会被服务器公钥加密。")]),v._v(" "),t("li",[v._v("加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),v._v(" "),t("li",[v._v("客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")])]),v._v(" "),t("p",[v._v("上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。此时"),t("strong",[v._v("服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("（4）服务器的最后回应")])]),v._v(" "),t("p",[v._v("服务器收到客户端的第三个随机数（"),t("code",[v._v("pre-master key")]),v._v("）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：")]),v._v(" "),t("ol",[t("li",[v._v("加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),v._v(" "),t("li",[v._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")])]),v._v(" "),t("p",[v._v("至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。")]),v._v(" "),t("h2",{attrs:{id:"数字证书签发和验证流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字证书签发和验证流程"}},[v._v("#")]),v._v(" 数字证书签发和验证流程？")]),v._v(" "),t("img",{staticStyle:{zoom:"60%"},attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202206131505538.png"}}),v._v(" "),t("p",[v._v("签发过程：")]),v._v(" "),t("ul",[t("li",[v._v("首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；")]),v._v(" "),t("li",[v._v("然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；")]),v._v(" "),t("li",[v._v("最后将 Certificate Signature 添加在文件证书上，形成数字证书；")])]),v._v(" "),t("p",[v._v("验证过程：")]),v._v(" "),t("ul",[t("li",[v._v("首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；")]),v._v(" "),t("li",[v._v("通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；")]),v._v(" "),t("li",[v._v("最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。")])]),v._v(" "),t("h2",{attrs:{id:"数字证书信任链验证过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字证书信任链验证过程"}},[v._v("#")]),v._v(" 数字证书信任链验证过程：")]),v._v(" "),t("p",[v._v("向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：")]),v._v(" "),t("p",[v._v("对于这种三级层级关系的证书的验证过程如下：")]),v._v(" "),t("ul",[t("li",[v._v("客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。")]),v._v(" "),t("li",[v._v("请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。")]),v._v(" "),t("li",[v._v("“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。")])]),v._v(" "),t("p",[v._v("在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("p",[v._v("为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。")])])])]),t("h2",{attrs:{id:"对称加密算法和非对称加密算法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对称加密算法和非对称加密算法有哪些"}},[v._v("#")]),v._v(" 对称加密算法和非对称加密算法有哪些？")]),v._v(" "),t("ul",[t("li",[v._v("对称加密算法：AES、DES、3DES\n"),t("ul",[t("li",[v._v("DES是一种分组数据加密技术（先将数据分成固定长度的小数据块，之后进行加密），速度较快，适用于大量数据加密；而3DES是一种基于DES的加密算法，使用3个不同密匙对同一个分组数据块进行3次加密，如此以使得密文强度更高。")])])]),v._v(" "),t("li",[v._v("非对称加密算法：RSA、DSA、ECC（椭圆加密）、ECDHE")])]),v._v(" "),t("h2",{attrs:{id:"http如何优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http如何优化"}},[v._v("#")]),v._v(" HTTP如何优化？")]),v._v(" "),t("ul",[t("li",[t("em",[v._v("尽量避免发送 HTTP 请求")]),v._v("："),t("strong",[v._v("使用缓存")]),v._v("，将重复性的响应数据缓存在本地")]),v._v(" "),t("li",[t("em",[v._v("在需要发送 HTTP 请求时，考虑如何减少请求次数")]),v._v("：\n"),t("ul",[t("li",[t("strong",[v._v("减少重定向请求次数")]),v._v("，将重定向的工作交由代理服务器完成")]),v._v(" "),t("li",[t("strong",[v._v("合并请求")]),v._v("，使用精灵图、合理利用webpack打包工具合并资源、图片使用base64编码等")]),v._v(" "),t("li",[t("strong",[v._v("延迟发送请求")]),v._v("，按需获取，如图片懒加载等")])])]),v._v(" "),t("li",[t("em",[v._v("减少服务器的 HTTP 响应的数据大小")]),v._v("：使用"),t("strong",[v._v("压缩")]),v._v("，即\n"),t("ul",[t("li",[v._v("无损压缩适合文本文件、程序可执行文件、程序源代码。如客户端在请求头中通过"),t("code",[v._v("Accept-Encoding")]),v._v(" 字段告诉服务器自己所支持的压缩算法，服务端响应中通过"),t("code",[v._v("content-encoding")]),v._v(" 字段告诉客户端该资源使用的压缩算法。")]),v._v(" "),t("li",[v._v("有损压缩适合用于压缩多媒体数据。如 HTTP 请求头部中的 "),t("code",[v._v("Accept")]),v._v(" 字段里的「 q 质量因子」，告诉服务器期望的资源质量。再比如，对于图片使用WebP格式，对于视频使用H264、H265编码，音频使用AAC、AC3编码等。")])])])]),v._v(" "),t("br"),v._v(" "),t("br"),v._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[v._v("参考资料")]),v._v(" "),t("p",[v._v("以上内容均整理自："),t("a",{attrs:{href:"https://xiaolincoding.com/network",target:"_blank",rel:"noopener noreferrer"}},[v._v("小林coding - 图解网络"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=o.exports}}]);