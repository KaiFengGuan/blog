(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{593:function(_,v,t){"use strict";t.r(v);var e=t(10),i=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("主要内容为：盒模型、视觉格式化模型、格式化上下文和层叠上下文")]),_._v(" "),t("h2",{attrs:{id:"_1-盒模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-盒模型"}},[_._v("#")]),_._v(" 1 盒模型")]),_._v(" "),t("p",[_._v("在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的："),t("strong",[_._v("内容（content）")]),_._v("、"),t("strong",[_._v("内边距（padding）")]),_._v("、"),t("strong",[_._v("边框（border）"),t("strong",[_._v("和")]),_._v("外边距（margin）")]),_._v("。")]),_._v(" "),t("p",[_._v("盒模型有 2 种：标准盒模型和 IE 盒模型，本别是由 W3C 和 IExplore 制定的标准。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202201091715085.webp",alt:""}})]),_._v(" "),t("ul",[t("li",[_._v("标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框")]),_._v(" "),t("li",[_._v("IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框")])]),_._v(" "),t("p",[_._v("一个例子：")]),_._v(" "),t("div",{staticClass:"language-css line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-css"}},[t("code",[t("span",{pre:!0,attrs:{class:"token selector"}},[_._v(".box")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[_._v("width")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" 200px"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[_._v("height")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" 200px"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[_._v("padding")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" 10px"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[_._v("border")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" 1px solid #eee"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[_._v("margin")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v(" 10px"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br"),t("span",{staticClass:"line-number"},[_._v("6")]),t("br"),t("span",{staticClass:"line-number"},[_._v("7")]),t("br")])]),t("p",[_._v("在这个例子中，不同盒模型下的盒子的实际尺寸为：")]),_._v(" "),t("ul",[t("li",[_._v("标准盒模型："),t("code",[_._v(".box")]),_._v(" 元素内容的宽度就为 "),t("code",[_._v("200px")]),_._v("，而实际的宽度则是 "),t("code",[_._v("width")]),_._v(" + "),t("code",[_._v("padding-left")]),_._v(" + "),t("code",[_._v("padding-right")]),_._v(" + "),t("code",[_._v("border-left-width")]),_._v(" + "),t("code",[_._v("border-right-width")]),_._v(" = 200 + 10 + 10 + 1 + 1 = 222；")]),_._v(" "),t("li",[_._v("IE 盒模型："),t("code",[_._v(".box")]),_._v(" 元素所占用的实际宽度为 "),t("code",[_._v("200px")]),_._v("，而内容的真实宽度则是 "),t("code",[_._v("width")]),_._v(" - "),t("code",[_._v("padding-left")]),_._v(" - "),t("code",[_._v("padding-right")]),_._v(" - "),t("code",[_._v("border-left-width")]),_._v(" - "),t("code",[_._v("border-right-width")]),_._v(" = 200 - 10 - 10 - 1 - 1 = 178。")])]),_._v(" "),t("p",[_._v("现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。")]),_._v(" "),t("p",[_._v("在  CSS3 中新增了一个属性 "),t("code",[_._v("box-sizing")]),_._v("，允许开发者来指定盒子使用什么标准，它有 2 个值：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("content-box")]),_._v("：标准盒模型；")]),_._v(" "),t("li",[t("code",[_._v("border-box")]),_._v("：IE 盒模型；")])]),_._v(" "),t("h2",{attrs:{id:"_2-视觉格式化模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-视觉格式化模型"}},[_._v("#")]),_._v(" 2 视觉格式化模型")]),_._v(" "),t("p",[_._v("CSS 视觉格式化模型（visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。该模型是 CSS 的基础概念之一。")]),_._v(" "),t("p",[_._v("视觉格式化模型会根据CSS盒子模型将文档中的元素转换为一个个盒子，每个盒子的布局由以下因素决定：")]),_._v(" "),t("ul",[t("li",[_._v("盒子的尺寸：精确指定、由约束条件指定或没有指定")]),_._v(" "),t("li",[_._v("盒子的类型：行内盒子（inline）、行内级盒子（inline-level）、原子行内级盒子（atomic inline-level）、块盒子（block）")]),_._v(" "),t("li",[_._v("定位方案（positioning scheme）：普通流定位、浮动定位或绝对定位")]),_._v(" "),t("li",[_._v("文档树中的其它元素：即当前盒子的子元素或兄弟元素")]),_._v(" "),t("li",[_._v("视口尺寸与位置")]),_._v(" "),t("li",[_._v("所包含的图片的尺寸")]),_._v(" "),t("li",[_._v("其他的某些外部因素")])]),_._v(" "),t("p",[_._v("该模型会根据盒子的包含块（containing block）的边界来渲染盒子。通常，盒子会创建一个包含其后代元素的包含块，但是盒子并不由包含块所限制，当盒子的布局跑到包含块的外面时称为溢出（overflow）。")]),_._v(" "),t("p",[_._v("盒子的生成是 CSS 视觉格式化模型的一部分，用于从文档元素生成盒子。盒子有不同的类型，不同类型的盒子的格式化方法也有所不同。盒子的类型取决于 CSS "),t("code",[_._v("display")]),_._v(" 属性。")]),_._v(" "),t("ul",[t("li",[_._v("outer display type（对外显示）：决定了"),t("strong",[_._v("该元素本身")]),_._v("是如何布局的，即参与何种格式化上下文；")]),_._v(" "),t("li",[_._v("inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其"),t("strong",[_._v("内部子元素")]),_._v("是如何布局的，参与何种格式化上下文。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/4f659e9524584a42bf22ffbccac8251b%7Etplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"_2-1-outer-display-type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-outer-display-type"}},[_._v("#")]),_._v(" 2.1 outer display type")]),_._v(" "),t("p",[_._v("对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。")]),_._v(" "),t("p",[_._v("依据上图可以列出都有哪些块级和行内级盒子：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("块级盒子")]),_._v("：参与 BFC，呈现垂直排列；"),t("code",[_._v("display")]),_._v(" 为 "),t("code",[_._v("block")]),_._v("、"),t("code",[_._v("list-item")]),_._v("、"),t("code",[_._v("table")]),_._v("、"),t("code",[_._v("flex")]),_._v("、"),t("code",[_._v("grid")]),_._v("、"),t("code",[_._v("flow-root")]),_._v(" 等；")]),_._v(" "),t("li",[t("strong",[_._v("行内级盒子")]),_._v("：参与 IFC，呈现水平排列；"),t("code",[_._v("display")]),_._v(" 为 "),t("code",[_._v("inline")]),_._v("、"),t("code",[_._v("inline-block")]),_._v("、"),t("code",[_._v("inline-table")]),_._v(" 等。")])]),_._v(" "),t("p",[_._v("block、inline 和 inline-block 的区别：")]),_._v(" "),t("p",[t("strong",[_._v("(1) block")])]),_._v(" "),t("ul",[t("li",[_._v("占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；")]),_._v(" "),t("li",[_._v("设置 width/height 将会生效；")]),_._v(" "),t("li",[_._v("设置 padding 和 margin 将会生效；")])]),_._v(" "),t("p",[t("strong",[_._v("(2) inline")])]),_._v(" "),t("ul",[t("li",[_._v("不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；")]),_._v(" "),t("li",[_._v("设置 width/height 将不会生效；")]),_._v(" "),t("li",[_._v("设置竖直方向上的 padding 和 margin 将不会生效；")])]),_._v(" "),t("p",[t("strong",[_._v("(3) inline-block")])]),_._v(" "),t("ul",[t("li",[_._v("是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；")]),_._v(" "),t("li",[_._v("设置 width/height 将会生效；")]),_._v(" "),t("li",[_._v("设置 padding 和 margin 将会生效；")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-inner-display-type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-inner-display-type"}},[_._v("#")]),_._v(" 2.2 inner display type")]),_._v(" "),t("p",[_._v("对内显示方面，其实就是把元素当成了"),t("strong",[_._v("容器")]),_._v("，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：")]),_._v(" "),t("ul",[t("li",[_._v("block container：建立 BFC 或者 IFC；")]),_._v(" "),t("li",[_._v("flex container：建立 FFC；")]),_._v(" "),t("li",[_._v("grid container：建立 GFC;")]),_._v(" "),t("li",[_._v("ruby container：接触不多，不做介绍。")])]),_._v(" "),t("p",[_._v("值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。")]),_._v(" "),t("h2",{attrs:{id:"_3-格式化上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-格式化上下文"}},[_._v("#")]),_._v(" 3 格式化上下文")]),_._v(" "),t("p",[_._v("FC（Formatting Contexts），是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。")]),_._v(" "),t("p",[_._v("不同类型的盒子有不同格式化上下文，大概有这 4 类：")]),_._v(" "),t("ul",[t("li",[_._v("BFC (Block Formatting Context) 块级格式化上下文；")]),_._v(" "),t("li",[_._v("IFC (Inline Formatting Context) 行内格式化上下文；")]),_._v(" "),t("li",[_._v("FFC (Flex Formatting Context) 弹性格式化上下文；")]),_._v(" "),t("li",[_._v("GFC (Grid Formatting Context) 格栅格式化上下文；")])]),_._v(" "),t("h3",{attrs:{id:"_3-1-bfc-块格式化上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-bfc-块格式化上下文"}},[_._v("#")]),_._v(" 3.1 BFC 块格式化上下文")]),_._v(" "),t("p",[_._v("是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/BFC.png",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"_1-bfc-渲染规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-bfc-渲染规则"}},[_._v("#")]),_._v(" (1) BFC 渲染规则")]),_._v(" "),t("ul",[t("li",[_._v("内部的盒子会在垂直方向，一个接一个地放置；")]),_._v(" "),t("li",[_._v("盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；")]),_._v(" "),t("li",[_._v("每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；")]),_._v(" "),t("li",[_._v("BFC 的区域不会与 float 盒子重叠；")]),_._v(" "),t("li",[_._v("BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。")]),_._v(" "),t("li",[_._v("计算 BFC 的高度时，浮动元素也参与计算。")])]),_._v(" "),t("h4",{attrs:{id:"_2-如何创建-bfc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何创建-bfc"}},[_._v("#")]),_._v(" (2) 如何创建 BFC？")]),_._v(" "),t("ul",[t("li",[_._v("根元素："),t("code",[_._v("html")])]),_._v(" "),t("li",[_._v("非溢出的可见元素："),t("code",[_._v("overflow")]),_._v(" 不为 "),t("code",[_._v("visible")])]),_._v(" "),t("li",[_._v("设置浮动："),t("code",[_._v("float")]),_._v(" 属性不为 "),t("code",[_._v("none")])]),_._v(" "),t("li",[_._v("设置定位："),t("code",[_._v("position")]),_._v(" 为 "),t("code",[_._v("absolute")]),_._v(" 或 "),t("code",[_._v("fixed")])]),_._v(" "),t("li",[_._v("定义成块级的非块级元素："),t("code",[_._v("display")]),_._v(": "),t("code",[_._v("inline-block")]),_._v("/"),t("code",[_._v("table-cell")]),_._v("/"),t("code",[_._v("table-caption")]),_._v("/"),t("code",[_._v("flex")]),_._v("/"),t("code",[_._v("inline-flex")]),_._v("/"),t("code",[_._v("grid")]),_._v("/"),t("code",[_._v("inline-grid")])])]),_._v(" "),t("h4",{attrs:{id:"_3-bfc-应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-bfc-应用"}},[_._v("#")]),_._v(" (3) BFC 应用")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("让浮动内容和周围的内容等高")]),_._v("。\n浮动造成的问题就是"),t("em",[_._v("父元素高度坍塌")]),_._v("，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("自适应两栏布局 / 防止浮动元素遮挡其他非浮动元素")]),_._v("。\n应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。例如右侧内容加上 "),t("code",[_._v("overflow: auto")]),_._v(" 或 "),t("code",[_._v("display: flow-root")]),_._v("。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("防止垂直 margin 合并")]),_._v("。\nBFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。")])])]),_._v(" "),t("h3",{attrs:{id:"_3-2-ifc-行内格式化上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-ifc-行内格式化上下文"}},[_._v("#")]),_._v(" 3.2 IFC 行内格式化上下文")]),_._v(" "),t("p",[_._v("IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/IFC.png",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"_1-ifc-渲染规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-ifc-渲染规则"}},[_._v("#")]),_._v(" (1) IFC 渲染规则")]),_._v(" "),t("ul",[t("li",[_._v("子元素在水平方向上一个接一个排列，在垂直方向上将以 "),t("em",[_._v("容器顶部")]),_._v(" 开始向下排列；")]),_._v(" "),t("li",[_._v("节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；")]),_._v(" "),t("li",[_._v("节点在垂直方向上以不同形式对齐；")]),_._v(" "),t("li",[_._v("能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的"),t("strong",[_._v("线盒（line box）")]),_._v("。线盒的宽度是由"),t("strong",[_._v("包含块（containing box）"),t("strong",[_._v("和与其中的")]),_._v("浮动")]),_._v("来决定；")]),_._v(" "),t("li",[_._v("IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。")]),_._v(" "),t("li",[_._v("IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；")]),_._v(" "),t("li",[_._v("当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；")]),_._v(" "),t("li",[_._v("当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。")])]),_._v(" "),t("h4",{attrs:{id:"_2-ifc-应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-ifc-应用场景"}},[_._v("#")]),_._v(" (2) IFC 应用场景")]),_._v(" "),t("ul",[t("li",[_._v("水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。")]),_._v(" "),t("li",[_._v("垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。")])]),_._v(" "),t("h2",{attrs:{id:"_7-层叠上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-层叠上下文"}},[_._v("#")]),_._v(" 7 层叠上下文")]),_._v(" "),t("p",[_._v("在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴，众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开。")]),_._v(" "),t("p",[_._v("文档中的层叠上下文由满足以下任意一个条件的元素形成：")]),_._v(" "),t("ul",[t("li",[_._v("文档根元素（"),t("code",[_._v("<html>")]),_._v("）；")]),_._v(" "),t("li",[t("code",[_._v("position")]),_._v(" 值为 "),t("code",[_._v("absolute")]),_._v("（绝对定位）或  "),t("code",[_._v("relative")]),_._v("（相对定位）且 "),t("code",[_._v("z-index")]),_._v(" 值不为 "),t("code",[_._v("auto")]),_._v(" 的元素；")]),_._v(" "),t("li",[t("code",[_._v("position")]),_._v(" 值为 "),t("code",[_._v("fixed")]),_._v("（固定定位）或 "),t("code",[_._v("sticky")]),_._v("（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；")]),_._v(" "),t("li",[t("code",[_._v("flex")]),_._v(" (flexbox (en-US)) 容器的子元素，且 "),t("code",[_._v("z-index")]),_._v(" 值不为 "),t("code",[_._v("auto")]),_._v("；")]),_._v(" "),t("li",[t("code",[_._v("grid")]),_._v(" (grid) 容器的子元素，且 "),t("code",[_._v("z-index")]),_._v(" 值不为 "),t("code",[_._v("auto")]),_._v("；")]),_._v(" "),t("li",[t("code",[_._v("opacity")]),_._v(" 属性值小于 "),t("code",[_._v("1")]),_._v(" 的元素；")]),_._v(" "),t("li",[t("code",[_._v("mix-blend-mode")]),_._v(" 属性值不为 "),t("code",[_._v("normal")]),_._v(" 的元素；")]),_._v(" "),t("li",[_._v("以下任意属性值不为 "),t("code",[_._v("none")]),_._v(" 的元素：\n"),t("ul",[t("li",[_._v("transform")]),_._v(" "),t("li",[_._v("filter")]),_._v(" "),t("li",[_._v("perspective")]),_._v(" "),t("li",[_._v("clip-path")]),_._v(" "),t("li",[_._v("mask / mask-image / mask-border")])])]),_._v(" "),t("li",[t("code",[_._v("isolation")]),_._v(" 属性值为 "),t("code",[_._v("isolate")]),_._v(" 的元素；")]),_._v(" "),t("li",[t("code",[_._v("-webkit-overflow-scrolling")]),_._v(" 属性值为 "),t("code",[_._v("touch")]),_._v(" 的元素；")]),_._v(" "),t("li",[t("code",[_._v("will-change")]),_._v(" 值设定了任一属性而该属性在 "),t("code",[_._v("non-initial")]),_._v(" 值时会创建层叠上下文的元素；")]),_._v(" "),t("li",[t("code",[_._v("contain")]),_._v(" 属性值为 "),t("code",[_._v("layout")]),_._v("、"),t("code",[_._v("paint")]),_._v(" 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。")])]),_._v(" "),t("p",[_._v("我们第一印象认为 z-index 的值越大，距离屏幕观察者就越近，那么层叠等级就越高，除此之外：")]),_._v(" "),t("ul",[t("li",[_._v("z-index 能够在层叠上下文中对元素的堆叠顺序起作用是"),t("strong",[_._v("必须配合定位")]),_._v("才可以；")]),_._v(" "),t("li",[_._v("除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受"),t("strong",[_._v("层叠等级")]),_._v("和"),t("strong",[_._v("层叠顺序")]),_._v("影响；")])]),_._v(" "),t("h3",{attrs:{id:"_7-1-层叠等级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-层叠等级"}},[_._v("#")]),_._v(" 7.1 层叠等级")]),_._v(" "),t("p",[_._v("层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：")]),_._v(" "),t("ul",[t("li",[_._v("在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；")]),_._v(" "),t("li",[_._v("在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；")])]),_._v(" "),t("p",[_._v("普通节点的层叠等级优先由其所在的层叠上下文决定，"),t("strong",[_._v("层叠等级的比较只有在当前层叠上下文中才有意义")]),_._v("，脱离当前层叠上下文的比较就变得无意义了。")]),_._v(" "),t("h3",{attrs:{id:"_7-2-层叠顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-层叠顺序"}},[_._v("#")]),_._v(" 7.2 层叠顺序")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/KaiFengGuan/imgs/main/202204011057280.webp",alt:""}})]),_._v(" "),t("p",[_._v("以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）：")]),_._v(" "),t("ul",[t("li",[_._v("层叠上下文的 border 和 background")]),_._v(" "),t("li",[_._v("z-index < 0 的子节点")]),_._v(" "),t("li",[_._v("标准流内块级（block）非定位的子节点")]),_._v(" "),t("li",[_._v("浮动非定位的子节点")]),_._v(" "),t("li",[_._v("标准流内行内（inline/inline-block）非定位的子节点")]),_._v(" "),t("li",[_._v("z-index: auto/0 的子节点")]),_._v(" "),t("li",[_._v("z-index > 0的子节点")])]),_._v(" "),t("h3",{attrs:{id:"_7-3-如何比较两个元素的层叠等级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-如何比较两个元素的层叠等级"}},[_._v("#")]),_._v(" 7.3 如何比较两个元素的层叠等级？")]),_._v(" "),t("ul",[t("li",[_._v("在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。")]),_._v(" "),t("li",[_._v("如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。")]),_._v(" "),t("li",[_._v("如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。")])]),_._v(" "),t("p",[_._v("扩展阅读："),t("a",{attrs:{href:"https://blog.csdn.net/llll789789/article/details/97562099",target:"_blank",rel:"noopener noreferrer"}},[_._v("彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index"),t("OutboundLink")],1)]),_._v(" "),t("br"),_._v(" "),t("br"),_._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[_._v("参考资料")]),_._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6941206439624966152",target:"_blank",rel:"noopener noreferrer"}},[_._v("1.5 万字 CSS 基础拾遗（核心知识、常见需求）"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);v.default=i.exports}}]);